/**
 * TestRuntime and harness for testing the CRE SDK runtime without WASM.
 * Registry is scoped per test via AsyncLocalStorage; use testWithRuntime to run tests with a registry.
 */
import { test as bunTest } from 'bun:test';
import { AsyncLocalStorage } from 'node:async_hooks';
import { create, toBinary } from '@bufbuild/protobuf';
import { anyPack, anyUnpack } from '@bufbuild/protobuf/wkt';
import { AttributedSignatureSchema, AwaitCapabilitiesResponseSchema, AwaitSecretsResponseSchema, CapabilityResponseSchema, ReportRequestSchema, ReportResponseSchema, SecretErrorSchema, SecretResponseSchema, SecretResponsesSchema, SecretSchema, SimpleConsensusInputsSchema, } from '../../generated/sdk/v1alpha/sdk_pb';
import { ValueSchema } from '../../generated/values/v1/values_pb';
import { RuntimeImpl } from '../impl/runtime-impl';
import { TestWriter } from './test-writer';
/** Error message when response exceeds max size. Used by the harness when its await implements the size check. */
export const RESPONSE_BUFFER_TOO_SMALL = 'response buffer too small';
export const DEFAULT_MAX_RESPONSE_SIZE_BYTES = 5 * 1024 * 1024;
export const REPORT_METADATA_HEADER_LENGTH = 109;
/** Registry is private; stored in AsyncLocalStorage when running inside testWithRuntime. */
class Registry {
    capabilities = new Map();
    mockInstances = new Map();
    register(id, handler) {
        if (this.capabilities.has(id)) {
            throw new Error(`capability already exists: ${id}`);
        }
        this.capabilities.set(id, handler);
    }
    get(id) {
        return this.capabilities.get(id);
    }
    getMockInstance(id) {
        return this.mockInstances.get(id);
    }
    setMockInstance(id, instance) {
        this.mockInstances.set(id, instance);
    }
}
const registryStorage = new AsyncLocalStorage();
/**
 * Returns the capability handler for the given id from the current test's registry, if any.
 * Only defined when called inside a testWithRuntime scope (after the handler is registered).
 */
export function getTestCapabilityHandler(id) {
    return registryStorage.getStore()?.get(id);
}
/**
 * Registers a capability handler for the current test's registry.
 * Must be called inside a testWithRuntime scope; throws if no registry is active.
 */
export function registerTestCapability(id, handler) {
    const registry = registryStorage.getStore();
    if (!registry) {
        throw new Error('registerTestCapability must be called from within a test in this package');
    }
    registry.register(id, handler);
}
/**
 * Gets a mock instance from the current test's registry, or undefined if not found or no registry active.
 * @internal Used by generated mocks for singleton pattern.
 */
export function __getTestMockInstance(id) {
    return registryStorage.getStore()?.getMockInstance(id);
}
/**
 * Stores a mock instance in the current test's registry.
 * @internal Used by generated mocks for singleton pattern.
 */
export function __setTestMockInstance(id, instance) {
    const registry = registryStorage.getStore();
    if (!registry) {
        throw new Error('mock instance management must be called from within a test in this package');
    }
    registry.setMockInstance(id, instance);
}
/**
 * Test-only: returns the current registry store (for cleanup/isolation assertions).
 * Do not use in production code.
 */
export function __testOnlyRegistryStore() {
    return registryStorage.getStore() ?? undefined;
}
/**
 * Test-only: runs a callback with a fresh registry and cleans up (for cleanup/failure tests).
 * Do not use in production code.
 */
export async function __testOnlyRunWithRegistry(fn) {
    const registry = new Registry();
    await registryStorage.run(registry, async () => {
        try {
            await fn();
        }
        finally {
            registryStorage.enterWith(undefined);
        }
    });
}
function defaultSimpleConsensus(input) {
    const obs = input.observation;
    if (obs.case === 'value') {
        return reportFromValue(obs.value);
    }
    if (obs.case === 'error') {
        if (input.default != null && input.default.value != null) {
            return reportFromValue(input.default);
        }
        throw new Error(obs.value);
    }
    throw new Error(`unknown observation type`);
}
function reportFromValue(value) {
    return create(ValueSchema, { value: value.value });
}
function createTestReportMetadata() {
    const metadata = new Uint8Array(REPORT_METADATA_HEADER_LENGTH);
    for (let i = 0; i < REPORT_METADATA_HEADER_LENGTH; i++) {
        metadata[i] = (i % 256);
    }
    return metadata;
}
function defaultReport(input) {
    const encodedPayload = typeof input.encodedPayload !== 'undefined'
        ? input.encodedPayload
        : new Uint8Array(0);
    const metadata = createTestReportMetadata();
    const rawReport = new Uint8Array(metadata.length + encodedPayload.length);
    rawReport.set(metadata);
    rawReport.set(encodedPayload, metadata.length);
    const sigs = [
        {
            signature: new TextEncoder().encode('default_signature_1'),
            signerId: 1,
        },
        {
            signature: new TextEncoder().encode('default_signature_2'),
            signerId: 2,
        },
    ];
    return { rawReport, sigs };
}
const CONSENSUS_CAPABILITY_ID = 'consensus@1.0.0-alpha';
function createTestRuntimeHelpers(registry, secrets, testWriter, state, _maxResponseSize) {
    const pendingCalls = new Map();
    const pendingSecrets = new Map();
    function now() {
        return state.timeProvider ? state.timeProvider() : Date.now();
    }
    return {
        call(request) {
            const handler = registry.get(request.id);
            if (!handler)
                return false;
            const payload = request.payload ?? {};
            try {
                const result = handler({
                    id: request.id,
                    method: request.method,
                    payload,
                });
                pendingCalls.set(request.callbackId, result.response);
            }
            catch (e) {
                pendingCalls.set(request.callbackId, {
                    case: 'error',
                    value: e instanceof Error ? e.message : String(e),
                });
            }
            return true;
        },
        await(request, maxResponseSizeBytes) {
            const responses = {};
            for (const id of request.ids) {
                const resp = pendingCalls.get(id);
                if (resp) {
                    responses[id] = create(CapabilityResponseSchema, { response: resp });
                    pendingCalls.delete(id);
                }
            }
            const response = create(AwaitCapabilitiesResponseSchema, { responses });
            const bytes = toBinary(AwaitCapabilitiesResponseSchema, response);
            if (bytes.length > Number(maxResponseSizeBytes)) {
                throw new Error(RESPONSE_BUFFER_TOO_SMALL);
            }
            return response;
        },
        getSecrets(req, _maxResponseSize) {
            const resp = [];
            for (const secretReq of req.requests) {
                const ns = secrets.get(secretReq.namespace || 'default');
                const value = ns?.get(secretReq.id);
                if (value === undefined) {
                    resp.push(create(SecretResponseSchema, {
                        response: {
                            case: 'error',
                            value: create(SecretErrorSchema, {
                                id: secretReq.id,
                                namespace: secretReq.namespace || 'default',
                                owner: '',
                                error: `could not find secret ${secretReq.namespace || 'default'}`,
                            }),
                        },
                    }));
                }
                else {
                    resp.push(create(SecretResponseSchema, {
                        response: {
                            case: 'secret',
                            value: create(SecretSchema, {
                                id: secretReq.id,
                                namespace: secretReq.namespace || 'default',
                                value,
                            }),
                        },
                    }));
                }
            }
            pendingSecrets.set(req.callbackId, resp);
            return true;
        },
        awaitSecrets(request, _maxResponseSize) {
            const responses = {};
            for (const id of request.ids) {
                const resp = pendingSecrets.get(id);
                if (!resp) {
                    throw new Error(`could not find call with id ${id}`);
                }
                responses[id] = create(SecretResponsesSchema, { responses: resp });
                pendingSecrets.delete(id);
            }
            return create(AwaitSecretsResponseSchema, { responses });
        },
        switchModes(_mode) { },
        now,
        log(message) {
            testWriter.log(message);
        },
    };
}
/**
 * Runs a test using the CRE runtime.
 */
export function test(title, fn) {
    bunTest(title, async () => {
        const registry = new Registry();
        try {
            return await registryStorage.run(registry, async () => fn());
        }
        finally {
            registryStorage.enterWith(undefined);
        }
    });
}
/**
 * Creates a test runtime. This must be called from within a test in this package.
 */
export function newTestRuntime(secrets, options = {}) {
    const secretsMap = secrets ?? new Map();
    const testWriter = new TestWriter();
    const registry = registryStorage.getStore() ?? new Registry();
    if (!registry.get(CONSENSUS_CAPABILITY_ID)) {
        registry.register(CONSENSUS_CAPABILITY_ID, (req) => {
            if (req.method === 'Simple') {
                const input = anyUnpack(req.payload, SimpleConsensusInputsSchema);
                const value = defaultSimpleConsensus(input);
                const packed = anyPack(ValueSchema, value);
                return { response: { case: 'payload', value: packed } };
            }
            if (req.method === 'Report') {
                const input = anyUnpack(req.payload, ReportRequestSchema);
                const { rawReport, sigs } = defaultReport(input);
                const reportResp = create(ReportResponseSchema, {
                    configDigest: new Uint8Array(0),
                    seqNr: 0n,
                    reportContext: new Uint8Array(0),
                    rawReport,
                    sigs: sigs.map((s) => create(AttributedSignatureSchema, s)),
                });
                const packed = anyPack(ReportResponseSchema, reportResp);
                return { response: { case: 'payload', value: packed } };
            }
            return {
                response: { case: 'error', value: `unknown method ${req.method}` },
            };
        });
    }
    const state = {
        timeProvider: options.timeProvider,
    };
    const maxResponseSize = BigInt(options.maxResponseSize ?? DEFAULT_MAX_RESPONSE_SIZE_BYTES);
    const helpers = createTestRuntimeHelpers(registry, secretsMap, testWriter, state, maxResponseSize);
    return new TestRuntime(helpers, maxResponseSize, testWriter, state);
}
/**
 * TestRuntime is a Runtime implementation for unit tests. Extends RuntimeImpl; construct via newTestRuntime.
 * Adds getLogs() and setTimeProvider(). Registry is accessed via getTestCapabilityHandler when inside testWithRuntime.
 */
export class TestRuntime extends RuntimeImpl {
    testWriter;
    state;
    constructor(helpers, maxResponseSize, testWriter, state) {
        super({}, 0, helpers, maxResponseSize);
        this.testWriter = testWriter;
        this.state = state;
    }
    getLogs() {
        return this.testWriter.getLogs();
    }
    setTimeProvider(timeProvider) {
        this.state.timeProvider = timeProvider;
    }
}
