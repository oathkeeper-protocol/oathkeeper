import { fromJson } from '@bufbuild/protobuf';
import { anyPack, anyUnpack } from '@bufbuild/protobuf/wkt';
import { BalanceAtReplySchema, BalanceAtRequestSchema, CallContractReplySchema, CallContractRequestSchema, EstimateGasReplySchema, EstimateGasRequestSchema, FilterLogsReplySchema, FilterLogsRequestSchema, GetTransactionByHashReplySchema, GetTransactionByHashRequestSchema, GetTransactionReceiptReplySchema, GetTransactionReceiptRequestSchema, HeaderByNumberReplySchema, HeaderByNumberRequestSchema, WriteReportReplySchema, WriteReportRequestSchema, } from '../../../../../../../generated/capabilities/blockchain/evm/v1alpha/client_pb';
import { __getTestMockInstance, __setTestMockInstance, registerTestCapability, } from '../../../../../../testutils/test-runtime';
/**
 * Mock for ClientCapability. Use testInstance() to obtain an instance; do not construct directly.
 * Set per-method properties (e.g. performAction) to define return values. If a method is invoked without a handler set, an error is thrown.
 */
export class EvmMock {
    static CAPABILITY_ID = 'evm@1.0.0';
    /** Set to define the return value for CallContract. May return a plain object (CallContractReplyJson) or the message type. */
    callContract;
    /** Set to define the return value for FilterLogs. May return a plain object (FilterLogsReplyJson) or the message type. */
    filterLogs;
    /** Set to define the return value for BalanceAt. May return a plain object (BalanceAtReplyJson) or the message type. */
    balanceAt;
    /** Set to define the return value for EstimateGas. May return a plain object (EstimateGasReplyJson) or the message type. */
    estimateGas;
    /** Set to define the return value for GetTransactionByHash. May return a plain object (GetTransactionByHashReplyJson) or the message type. */
    getTransactionByHash;
    /** Set to define the return value for GetTransactionReceipt. May return a plain object (GetTransactionReceiptReplyJson) or the message type. */
    getTransactionReceipt;
    /** Set to define the return value for HeaderByNumber. May return a plain object (HeaderByNumberReplyJson) or the message type. */
    headerByNumber;
    /** Set to define the return value for WriteReport. May return a plain object (WriteReportReplyJson) or the message type. */
    writeReport;
    constructor(chainSelector) {
        const self = this;
        const qualifiedId = `evm:ChainSelector:${chainSelector}@1.0.0`;
        try {
            registerTestCapability(qualifiedId, (req) => {
                switch (req.method) {
                    case 'CallContract': {
                        const input = anyUnpack(req.payload, CallContractRequestSchema);
                        const handler = self.callContract;
                        if (typeof handler !== 'function')
                            throw new Error("CallContract: no implementation provided; set the mock's callContract property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(CallContractReplySchema, raw);
                        return {
                            response: { case: 'payload', value: anyPack(CallContractReplySchema, output) },
                        };
                    }
                    case 'FilterLogs': {
                        const input = anyUnpack(req.payload, FilterLogsRequestSchema);
                        const handler = self.filterLogs;
                        if (typeof handler !== 'function')
                            throw new Error("FilterLogs: no implementation provided; set the mock's filterLogs property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(FilterLogsReplySchema, raw);
                        return { response: { case: 'payload', value: anyPack(FilterLogsReplySchema, output) } };
                    }
                    case 'BalanceAt': {
                        const input = anyUnpack(req.payload, BalanceAtRequestSchema);
                        const handler = self.balanceAt;
                        if (typeof handler !== 'function')
                            throw new Error("BalanceAt: no implementation provided; set the mock's balanceAt property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(BalanceAtReplySchema, raw);
                        return { response: { case: 'payload', value: anyPack(BalanceAtReplySchema, output) } };
                    }
                    case 'EstimateGas': {
                        const input = anyUnpack(req.payload, EstimateGasRequestSchema);
                        const handler = self.estimateGas;
                        if (typeof handler !== 'function')
                            throw new Error("EstimateGas: no implementation provided; set the mock's estimateGas property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(EstimateGasReplySchema, raw);
                        return { response: { case: 'payload', value: anyPack(EstimateGasReplySchema, output) } };
                    }
                    case 'GetTransactionByHash': {
                        const input = anyUnpack(req.payload, GetTransactionByHashRequestSchema);
                        const handler = self.getTransactionByHash;
                        if (typeof handler !== 'function')
                            throw new Error("GetTransactionByHash: no implementation provided; set the mock's getTransactionByHash property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(GetTransactionByHashReplySchema, raw);
                        return {
                            response: {
                                case: 'payload',
                                value: anyPack(GetTransactionByHashReplySchema, output),
                            },
                        };
                    }
                    case 'GetTransactionReceipt': {
                        const input = anyUnpack(req.payload, GetTransactionReceiptRequestSchema);
                        const handler = self.getTransactionReceipt;
                        if (typeof handler !== 'function')
                            throw new Error("GetTransactionReceipt: no implementation provided; set the mock's getTransactionReceipt property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(GetTransactionReceiptReplySchema, raw);
                        return {
                            response: {
                                case: 'payload',
                                value: anyPack(GetTransactionReceiptReplySchema, output),
                            },
                        };
                    }
                    case 'HeaderByNumber': {
                        const input = anyUnpack(req.payload, HeaderByNumberRequestSchema);
                        const handler = self.headerByNumber;
                        if (typeof handler !== 'function')
                            throw new Error("HeaderByNumber: no implementation provided; set the mock's headerByNumber property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(HeaderByNumberReplySchema, raw);
                        return {
                            response: { case: 'payload', value: anyPack(HeaderByNumberReplySchema, output) },
                        };
                    }
                    case 'WriteReport': {
                        const input = anyUnpack(req.payload, WriteReportRequestSchema);
                        const handler = self.writeReport;
                        if (typeof handler !== 'function')
                            throw new Error("WriteReport: no implementation provided; set the mock's writeReport property to define the return value.");
                        const raw = handler(input);
                        const output = raw && typeof raw.$typeName === 'string'
                            ? raw
                            : fromJson(WriteReportReplySchema, raw);
                        return { response: { case: 'payload', value: anyPack(WriteReportReplySchema, output) } };
                    }
                    default:
                        return { response: { case: 'error', value: `unknown method ${req.method}` } };
                }
            });
        }
        catch {
            throw new Error("Capability mocks must be used within the CRE test framework's test() method.");
        }
    }
    /**
     * Returns the mock instance for this capability and the specified tags.
     * Multiple calls with the same tag values return the same instance.
     * Must be called within the test framework's test() method.
     */
    static testInstance(chainSelector) {
        const qualifiedId = `evm:ChainSelector:${chainSelector}@1.0.0`;
        let instance = __getTestMockInstance(qualifiedId);
        if (!instance) {
            instance = new EvmMock(chainSelector);
            __setTestMockInstance(qualifiedId, instance);
        }
        return instance;
    }
}
